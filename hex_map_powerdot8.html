<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>UK AQ Hex Map – Power 0.8</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --ink: #142225;
        --ink-soft: #334449;
        --mist: #f6f1e9;
        --teal: #0f8b8d;
        --teal-deep: #0a5d61;
        --sun: #f4b942;
        --clay: #e8dcc7;
        --no-data: #efe6d8;
        --fog: rgba(20, 34, 37, 0.08);
        --card: #ffffff;
        --heat-0: #00a85a;
        --heat-1: #ffd54a;
        --heat-2: #ff9b3a;
        --heat-3: #e03c3c;
        --heat-4: #5b2a86;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 12% 20%, #ffe8c7 0%, transparent 55%),
          radial-gradient(circle at 88% 18%, #d6f1ef 0%, transparent 50%),
          linear-gradient(135deg, #f7f2e8, #f0f7f6);
        min-height: 100vh;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(120deg, rgba(20, 34, 37, 0.05) 1px, transparent 1px);
        background-size: 32px 32px;
        opacity: 0.2;
        pointer-events: none;
      }

      main {
        position: relative;
        max-width: 1200px;
        margin: 0 auto;
        padding: 48px 24px 64px;
        display: grid;
        gap: 24px;
      }

      header {
        display: grid;
        gap: 12px;
        align-items: start;
      }

      .title {
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        font-size: clamp(2rem, 2.6vw, 3.25rem);
        letter-spacing: -0.02em;
        margin: 0;
      }

      .subtitle {
        margin: 0;
        color: var(--ink-soft);
        font-size: 1.05rem;
        max-width: 720px;
      }

      .meta {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 0.9rem;
        color: var(--ink-soft);
      }

      .badge {
        background: var(--clay);
        color: var(--ink);
        padding: 4px 10px;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 0.72rem;
      }

      .card {
        background: var(--card);
        border-radius: 18px;
        box-shadow: 0 20px 50px rgba(20, 34, 37, 0.12);
        padding: 24px;
        display: grid;
        gap: 16px;
        animation: floatIn 0.6s ease-out;
      }

      .map-layout {
        display: grid;
        grid-template-columns: 1fr;
        gap: 24px;
        align-items: start;
      }

      .map-panel {
        display: grid;
        gap: 16px;
      }

      .summary-card {
        padding: 16px;
        border-radius: 16px;
        background: #fff;
        border: 1px solid rgba(20, 34, 37, 0.12);
        display: grid;
        gap: 12px;
      }

      .summary-title {
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        margin: 0;
        font-size: 1.2rem;
      }

      .summary-list {
        display: grid;
        gap: 14px;
      }

      .summary-item {
        padding: 12px 14px;
        border-radius: 14px;
        background: var(--mist);
        border: 1px solid var(--fog);
        display: grid;
        gap: 6px;
      }

      .summary-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--ink-soft);
      }

      .summary-value {
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--ink);
      }

      .summary-name {
        font-size: 0.9rem;
        color: var(--ink-soft);
      }

      .summary-connector {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--teal-deep);
      }

      .card-header {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: space-between;
        align-items: center;
      }

      .card-title {
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        margin: 0;
        font-size: 1.4rem;
      }

      .actions {
        display: flex;
        gap: 12px;
        align-items: center;
        font-size: 0.9rem;
        color: var(--ink-soft);
      }

      .actions button {
        border: none;
        background: var(--teal);
        color: white;
        padding: 8px 14px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(15, 139, 141, 0.25);
      }

      .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        font-size: 0.9rem;
        color: var(--ink-soft);
      }

      .filters label {
        font-weight: 600;
        color: var(--ink);
      }

      .filters input[type="text"],
      .filters input[type="search"] {
        background: #fff;
        border: 1px solid rgba(20, 34, 37, 0.15);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.9rem;
        color: var(--ink);
      }

      .network-panel {
        padding: 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid rgba(20, 34, 37, 0.12);
        display: grid;
        gap: 12px;
      }

      .network-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }

      .network-actions button {
        border: none;
        background: var(--clay);
        color: var(--ink);
        padding: 8px 10px;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .network-actions button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 8px 14px rgba(20, 34, 37, 0.12);
      }

      .network-actions button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
      }

      .network-panel .checkbox {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(20, 34, 37, 0.12);
        background: var(--mist);
        font-weight: 600;
        color: var(--ink);
        font-size: 0.85rem;
      }

      .network-panel input[type="checkbox"] {
        width: 14px;
        height: 14px;
        accent-color: var(--teal);
      }

      .network-list {
        display: grid;
        gap: 8px;
        max-height: 360px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .network-empty {
        color: var(--ink-soft);
        font-size: 0.85rem;
      }

      .map-wrap {
        border-radius: 16px;
        background: #fdfaf4;
        padding: 16px;
        border: 1px solid rgba(20, 34, 37, 0.08);
        display: grid;
        grid-template-columns: minmax(200px, 0.35fr) minmax(0, 1fr) minmax(220px, 0.45fr);
        gap: 16px;
        align-items: start;
        position: relative;
      }

      .map-canvas {
        min-width: 0;
      }

      .map-legend {
        grid-column: 1 / -1;
        justify-content: center;
      }

      .map-settings {
        position: absolute;
        left: 16px;
        bottom: 16px;
        z-index: 2;
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: 1px solid rgba(20, 34, 37, 0.2);
        background: #fff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(20, 34, 37, 0.12);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .map-settings:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(20, 34, 37, 0.18);
      }

      .map-settings img {
        width: 20px;
        height: 20px;
        display: block;
      }

      .map-settings-panel {
        position: absolute;
        left: 16px;
        bottom: 68px;
        width: auto;
        background: #fff;
        border-radius: 14px;
        border: 1px solid rgba(20, 34, 37, 0.18);
        box-shadow: 0 14px 32px rgba(20, 34, 37, 0.18);
        padding: 12px;
        display: none;
        z-index: 3;
      }

      .map-settings-panel.open {
        display: grid;
        gap: 10px;
      }

      .map-settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .map-settings-title {
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--ink);
      }

      .map-settings-close {
        border: none;
        background: none;
        padding: 0;
        width: 24px;
        height: 24px;
        cursor: pointer;
      }

      .map-settings-close img {
        width: 24px;
        height: 24px;
        display: block;
      }

      .map-settings-options {
        display: grid;
        gap: 8px;
        font-size: 0.88rem;
        color: var(--ink);
      }

      .map-settings-option {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .map-settings-option input {
        accent-color: var(--teal);
      }

      svg {
        width: 100%;
        height: 560px;
        display: block;
      }

      .hex {
        stroke: rgba(20, 34, 37, 0.12);
        stroke-width: 1;
        transition: fill 0.2s ease, stroke 0.2s ease;
      }

      .hex:hover {
        stroke: rgba(20, 34, 37, 0.4);
        stroke-width: 1.5;
      }

      .region-boundaries {
        pointer-events: none;
      }

      .boundary-path {
        fill: none;
        stroke: rgba(20, 34, 37, 0.6);
        stroke-width: 1.4;
        stroke-linecap: round;
        stroke-linejoin: round;
        vector-effect: non-scaling-stroke;
      }

      .boundary-country {
        stroke-width: 1.8;
      }

      .legend {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        font-size: 0.85rem;
        color: var(--ink-soft);
      }

      .legend-scale {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .legend-bar-wrap {
        position: relative;
        width: 200px;
        height: 18px;
        display: inline-flex;
        align-items: center;
      }

      .legend-bar {
        width: 100%;
        height: 12px;
        border-radius: 999px;
        background: linear-gradient(
          90deg,
          var(--heat-0),
          var(--heat-1),
          var(--heat-2),
          var(--heat-3),
          var(--heat-4)
        );
        border: 1px solid rgba(20, 34, 37, 0.12);
        display: block;
      }

      .legend-value {
        min-width: 42px;
        text-align: center;
        font-variant-numeric: tabular-nums;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
      }

      .legend-tick {
        position: absolute;
        top: 0;
        width: 2px;
        height: 18px;
        background: rgba(20, 34, 37, 0.45);
        border-radius: 2px;
        pointer-events: none;
      }

      .legend-tick-label {
        position: absolute;
        top: 18px;
        transform: translateX(-50%);
        font-size: 0.7rem;
        color: var(--ink-soft);
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        pointer-events: none;
      }

      .tooltip {
        position: fixed;
        pointer-events: none;
        background: white;
        border-radius: 10px;
        padding: 8px 12px;
        min-width: 320px;
        max-width: 360px;
        box-shadow: 0 10px 20px rgba(20, 34, 37, 0.18);
        font-size: 0.85rem;
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        opacity: 0;
        transform: translateY(8px);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .tooltip-title {
        font-weight: 700;
      }

      .tooltip-line {
        margin-top: 2px;
      }

      .tooltip-empty {
        margin-top: 6px;
        font-weight: 600;
      }

        .tooltip-table {
          display: grid;
          grid-template-columns: minmax(0, 1fr) 72px 96px;
          column-gap: 8px;
          row-gap: 6px;
          margin-top: 10px;
          align-items: start;
          padding: 10px 12px 10px 12px;
          background: #f7f2e8;
          border: 1px solid rgba(20, 34, 37, 0.14);
          border-radius: 12px;
          position: relative;
        }

        .tooltip-head {
          font-size: 0.72rem;
          letter-spacing: 0.04em;
          text-transform: uppercase;
          font-weight: 700;
          color: var(--ink-soft);
        }

        .tooltip-head:nth-of-type(2),
        .tooltip-head:nth-of-type(3),
        .tooltip-value,
        .tooltip-updated {
          padding-left: 10px;
        }

        .tooltip-head:nth-of-type(3) {
          padding-left: 4px;
        }

        .tooltip-updated {
          padding-left: 4px;
          padding-right: 16px;
        }

        .tooltip-vline {
          position: absolute;
          top: 12px;
          bottom: 12px;
          width: 1px;
          background: rgba(20, 34, 37, 0.16);
          pointer-events: none;
        }

        .tooltip-vline--1 {
          left: calc(100% - 192px);
        }

        .tooltip-vline--2 {
          left: calc(100% - 116px);
        }

        .tooltip-connector {
          grid-column: 1 / -1;
          font-weight: 700;
          margin-top: 4px;
          color: var(--teal-deep);
        }

        .tooltip-connector--spaced {
          margin-top: 10px;
        }

        .tooltip-row-divider {
          grid-column: 1 / -1;
          height: 1px;
          background: rgba(20, 34, 37, 0.12);
          margin: 2px 0;
        }

        .tooltip-row-divider--header {
          margin: 6px 0 4px;
        }

        .tooltip-station {
          font-weight: 700;
          color: var(--ink);
        }

        .tooltip-value,
        .tooltip-updated {
          text-align: left;
          font-variant-numeric: tabular-nums;
        }

        .tooltip-updated {
          white-space: nowrap;
          color: var(--ink-soft);
          font-size: 0.8rem;
        }

      .tooltip.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .hint {
        font-size: 0.85rem;
        color: var(--ink-soft);
      }

      .toggle {
        display: inline-flex;
        gap: 4px;
        padding: 4px;
        border-radius: 999px;
        border: 1px solid rgba(20, 34, 37, 0.12);
        background: #fff;
      }

      .toggle button {
        border: none;
        background: transparent;
        color: var(--ink-soft);
        padding: 6px 12px;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }

      .toggle button.active {
        background: var(--ink);
        color: #fff;
      }

      .error {
        color: #8b1e3f;
        font-weight: 600;
      }

      @keyframes floatIn {
        from {
          opacity: 0;
          transform: translateY(16px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 720px) {
        main {
          padding: 36px 18px 48px;
        }

        .card {
          padding: 18px;
        }

        svg {
          height: 420px;
        }
      }

      @media (max-width: 980px) {
        .map-layout {
          grid-template-columns: 1fr;
        }

        .map-wrap {
          grid-template-columns: 1fr;
        }

        .summary-card {
          order: 3;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <p class="badge">Hex Cartogram</p>
        <h1 class="title">UK AQ hex map – Power 0.8</h1>
        <p class="subtitle">
          Power-eased colour scale (exponent 0.8 with a small top boost) to pull low values closer to mid-range colours.
        </p>
        <div class="meta">
          <span id="row-count">Loading…</span>
          <span id="last-updated">Waiting for data</span>
        </div>
      </header>

      <section class="card">
        <div class="card-header">
          <h2 class="card-title">Latest PM2.5 by constituency</h2>
          <div class="actions">
            <span class="hint" id="status">Fetching from Supabase…</span>
            <button id="refresh">Refresh</button>
          </div>
        </div>
        <div class="filters">
          <span class="hint">Metric: Latest PM2.5</span>
          <div class="toggle" role="group" aria-label="Aggregation">
            <button type="button" class="active" data-metric="mean">Average (mean)</button>
            <button type="button" data-metric="median">Typical (median)</button>
          </div>
          <span class="hint">Parliamentary constituency hex cartogram (equal-pop)</span>
        </div>
        <div class="hint" id="endpoint-hint"></div>
        <div class="error" id="error"></div>
        <div class="map-layout">
          <div class="map-panel">
            <div class="map-wrap">
              <aside class="network-panel">
                <div class="network-actions" role="group" aria-label="Network selection actions">
                  <button type="button" id="network-select-all">Select All</button>
                  <button type="button" id="network-deselect-all">Deselect All</button>
                </div>
                <span class="hint">Networks</span>
                <div class="network-list" id="network-list">
                  <span class="network-empty">Loading networks...</span>
                </div>
              </aside>
              <div class="map-canvas">
                <svg id="hex-map" role="img" aria-label="Hex cartogram of PM2.5 by constituency"></svg>
              </div>
              <aside class="summary-card">
                <h3 class="summary-title">PM2.5 summary</h3>
                <div class="summary-list">
                  <div class="summary-item">
                    <span class="summary-label">Number of stations</span>
                    <span class="summary-value" id="summary-stations">-</span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Highest PM2.5</span>
                    <span class="summary-value" id="summary-highest-value">-</span>
                    <span class="summary-connector" id="summary-highest-connector">-</span>
                    <span class="summary-name" id="summary-highest-name">-</span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Lowest PM2.5 (Non-zero)</span>
                    <span class="summary-value" id="summary-lowest-value">-</span>
                    <span class="summary-connector" id="summary-lowest-connector">-</span>
                    <span class="summary-name" id="summary-lowest-name">-</span>
                  </div>
                </div>
              </aside>
              <div class="legend map-legend">
                <span>PM2.5 (µg/m³)</span>
                <div
                  id="legend-scale"
                  class="legend-scale"
                  title="Power scale (exp 0.8 with a slight top boost): pulls low values toward mid-range; values above 50 are shown as 50+."
                  aria-label="Power scale (exp 0.8 with a slight top boost): pulls low values toward mid-range; values above 50 are shown as 50+."
                >
                  <span class="legend-value" id="legend-min">-</span>
                  <div class="legend-bar-wrap" aria-hidden="true">
                    <span class="legend-bar"></span>
                    <span class="legend-tick" data-value="10"></span>
                    <span class="legend-tick" data-value="20"></span>
                    <span class="legend-tick" data-value="30"></span>
                    <span class="legend-tick" data-value="40"></span>
                    <span class="legend-tick-label" data-value="10">10</span>
                    <span class="legend-tick-label" data-value="20">20</span>
                    <span class="legend-tick-label" data-value="30">30</span>
                    <span class="legend-tick-label" data-value="40">40</span>
                  </div>
                  <span class="legend-value" id="legend-max">-</span>
                </div>
                <span id="legend-label"></span>
              </div>
              <div class="map-settings-panel" id="map-settings-panel" role="dialog" aria-label="Colour Scale">
                <div class="map-settings-header">
                  <span class="map-settings-title">Colour Scale</span>
                  <button type="button" class="map-settings-close" id="map-settings-close" aria-label="Close colour scale">
                    <img src="data/images/Red-Square-Button-White-Cross-200x200.svg" alt="" aria-hidden="true" />
                  </button>
                </div>
                <div class="map-settings-options" role="group" aria-label="Colour scale options">
                  <label class="map-settings-option">
                    <input type="radio" name="color-scale" value="power" />
                    Power-eased
                  </label>
                  <label class="map-settings-option">
                    <input type="radio" name="color-scale" value="linear" />
                    Linear
                  </label>
                </div>
              </div>
              <button type="button" class="map-settings" aria-label="Map settings" aria-controls="map-settings-panel" aria-expanded="false">
                <img src="data/images/settings-cog.svg" alt="" aria-hidden="true" />
              </button>
            </div>
          </div>
        </div>
      </section>
    </main>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js" crossorigin="anonymous"></script>
    <script>
      const PROJECT_REF_PLACEHOLDER = "nmgierafoeuxfkkscrln";
      const ANON_KEY_PLACEHOLDER = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5tZ2llcmFmb2V1eGZra3NjcmxuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUzMjIzMDMsImV4cCI6MjA4MDg5ODMwM30.x6rKhvMTFRyJCZNlaFG-5tUiSuwehCLLu3qbulNTe7A";
      const params = new URLSearchParams(window.location.search);
      const projectRefParam = params.get("project_ref");
      const anonKeyParam = params.get("anon_key");
      const metricParam = params.get("metric");
      const colorScaleParam = params.get("color_scale");
      const mapDateParam = params.get("map_date");
      const pconVersionParam = params.get("pcon_version");
      const inferredProjectRef = inferProjectRefFromHost();
      const projectRef = PROJECT_REF_PLACEHOLDER.includes("__SUPABASE_PROJECT_REF__")
        ? (projectRefParam || inferredProjectRef || "")
        : PROJECT_REF_PLACEHOLDER;
      const anonKey = ANON_KEY_PLACEHOLDER.includes("__SUPABASE_ANON_KEY__")
        ? (anonKeyParam || "")
        : ANON_KEY_PLACEHOLDER;
      const REST_URL = projectRef
        ? `https://${projectRef}.supabase.co/functions/v1/uk_aq_pcon_hex`
        : "";
      const LATEST_URL = projectRef
        ? `https://${projectRef}.supabase.co/functions/v1/uk_aq_latest`
        : "";
      const POPULATION_URL = projectRef
        ? `https://${projectRef}.supabase.co/functions/v1/uk_aq_population`
        : "";
      const MAP_CUTOVER = "2023-11-29";
      const MAP_CONFIGS = [
        {
          id: "pcon24",
          label: "2024 constituencies",
          hexUrl: "data/PCON/uk-constituencies-2023.hexjson",
          version: "2024",
          effectiveFrom: MAP_CUTOVER,
        },
        {
          id: "pcon23",
          label: "Pre-2024 constituencies",
          hexUrl: "data/PCON/uk-constituencies-2017.hexjson",
          version: "2023",
          effectiveUntil: MAP_CUTOVER,
        },
      ];
      const mapDateKey = normalizeDateKey(mapDateParam);
      const activeMap = pickMapConfig(mapDateKey);
      const HEX_DATA_URL = activeMap.hexUrl;
      const activePconVersion = pconVersionParam || activeMap.version;
        const METRIC_LABELS = {
          median: "Typical (median)",
          mean: "Average (mean)",
        };
        const MIN_VALID_PM25_VALUE = 0.09;
        const MAX_VALID_PM25_VALUE = 500;
      const CONNECTOR_DEFS = [
        { code: "uk_air_sos", label: "UK AIR SOS" },
        { code: "sensorcommunity", label: "Sensor Community" },
      ];

      function getConnectorLabelByCode(code) {
        const match = CONNECTOR_DEFS.find((def) => def.code === code);
        return match ? match.label : code;
      }
      const HEAT_STOPS = ["--heat-0", "--heat-1", "--heat-2", "--heat-3", "--heat-4"];
      const HEAT_STOP_FALLBACKS = ["#00a85a", "#ffd54a", "#ff9b3a", "#e03c3c", "#5b2a86"];
      const REGION_NAMES = {
        E12000001: "North East",
        E12000002: "North West",
        E12000003: "Yorkshire and The Humber",
        E12000004: "East Midlands",
        E12000005: "West Midlands",
        E12000006: "East of England",
        E12000007: "London",
        E12000008: "South East",
        E12000009: "South West",
        S92000003: "Scotland",
        W92000004: "Wales",
        N92000002: "Northern Ireland",
      };
      const AXIAL_DIRECTIONS = [
        { q: 1, r: 0 },
        { q: 1, r: -1 },
        { q: 0, r: -1 },
        { q: -1, r: 0 },
        { q: -1, r: 1 },
        { q: 0, r: 1 },
      ];
      const EDGE_DIRECTION_CACHE = new Map();

      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      const rowCount = document.getElementById("row-count");
      const lastUpdated = document.getElementById("last-updated");
      const endpointHint = document.getElementById("endpoint-hint");
      const legendLabel = document.getElementById("legend-label");
      const legendMin = document.getElementById("legend-min");
      const legendMax = document.getElementById("legend-max");
      const legendScale = document.getElementById("legend-scale");
      const legendTicks = Array.from(document.querySelectorAll(".legend-tick"));
      const legendTickLabels = Array.from(document.querySelectorAll(".legend-tick-label"));
      const summaryStations = document.getElementById("summary-stations");
      const summaryLowestValue = document.getElementById("summary-lowest-value");
      const summaryLowestConnector = document.getElementById("summary-lowest-connector");
      const summaryLowestName = document.getElementById("summary-lowest-name");
      const summaryHighestValue = document.getElementById("summary-highest-value");
      const summaryHighestConnector = document.getElementById("summary-highest-connector");
      const summaryHighestName = document.getElementById("summary-highest-name");
      const tooltip = document.getElementById("tooltip");
      const svg = d3.select("#hex-map");
      const mapSettingsButton = document.querySelector(".map-settings");
      const mapSettingsPanel = document.getElementById("map-settings-panel");
      const mapSettingsClose = document.getElementById("map-settings-close");
      const colorScaleInputs = Array.from(document.querySelectorAll("input[name='color-scale']"));
      const networkPanel = document.querySelector(".network-panel");
      const metricButtons = Array.from(document.querySelectorAll("[data-metric]"));
      const networkList = document.getElementById("network-list");
      const networkSelectAll = document.getElementById("network-select-all");
      const networkDeselectAll = document.getElementById("network-deselect-all");

      let currentMetric = metricParam === "median" ? "median" : "mean";
      let currentColorScale = colorScaleParam === "linear" ? "linear" : "power";
      let hexData = null;
      let hexCells = [];
      let hexBounds = null;
      let hexSide = null;
      let hexLayout = "odd-r";
      let basePconRows = [];
      let basePconLookup = new Map();
      let pconRows = [];
      let pconLookup = new Map();
      let pconCodes = new Set();
      let boundaryPaths = [];
      let baseLatestRows = [];
      let latestRows = [];
      let latestPollutant = null;
      let populationLookup = new Map();
      let networkInputs = [];

      endpointHint.textContent = REST_URL
        ? `Endpoint: ${REST_URL} (${activeMap.label})`
        : "Missing project ref. Add ?project_ref=... to the URL.";

      function inferProjectRefFromHost() {
        const host = window.location.hostname || "";
        if (host.endsWith(".supabase.co")) {
          return host.split(".")[0];
        }
        return null;
      }

      function normalizeDateKey(value) {
        if (!value) {
          return null;
        }
        const trimmed = value.trim();
        if (!/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
          return null;
        }
        return trimmed;
      }

      function pickMapConfig(dateKey) {
        if (!dateKey) {
          return MAP_CONFIGS[0];
        }
        return dateKey < MAP_CUTOVER ? MAP_CONFIGS[1] : MAP_CONFIGS[0];
      }

      function normalizeNumber(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function clampPm25(value) {
        const numeric = normalizeNumber(value);
        if (numeric === null) {
          return null;
        }
        if (numeric > MAX_VALID_PM25_VALUE) {
          return null;
        }
        return numeric;
      }

      function formatNumber(value) {
        if (value === null || value === undefined || Number.isNaN(value)) {
          return "-";
        }
        return value.toLocaleString();
      }

      function formatValue(value) {
        const numeric = normalizeNumber(value);
        if (numeric === null) {
          return "-";
        }
        return numeric.toFixed(1);
      }

      function formatTimestamp(value) {
        if (!value) {
          return "unknown";
        }
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return "unknown";
        }
        return parsed.toLocaleString();
      }

      function formatShortTimestamp(value) {
        if (!value) {
          return "-";
        }
        const parsed = value instanceof Date ? value : new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return "-";
        }
        const day = String(parsed.getDate()).padStart(2, "0");
        const month = String(parsed.getMonth() + 1).padStart(2, "0");
        const year = String(parsed.getFullYear()).slice(-2);
        const hours = String(parsed.getHours()).padStart(2, "0");
        const minutes = String(parsed.getMinutes()).padStart(2, "0");
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      }

      function parseDate(value) {
        if (!value) {
          return null;
        }
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return null;
        }
        return parsed;
      }

      function setQueryParam(key, value) {
        const url = new URL(window.location.href);
        if (value === null || value === undefined || value === "") {
          url.searchParams.delete(key);
        } else {
          url.searchParams.set(key, value);
        }
        window.history.replaceState({}, "", url);
      }

      function syncColorScaleInputs() {
        colorScaleInputs.forEach((input) => {
          input.checked = input.value === currentColorScale;
        });
      }

      function updateLegendScaleDescription() {
        if (!legendScale) {
          return;
        }
        const description = currentColorScale === "linear"
          ? "Linear colour scale: values map directly; values above 50 are shown as 50+."
          : "Power-eased colour scale: pulls low values toward mid-range; values above 50 are shown as 50+.";
        legendScale.title = description;
        legendScale.setAttribute("aria-label", description);
      }

      function openSettingsPanel() {
        if (!mapSettingsPanel || !mapSettingsButton) {
          return;
        }
        syncSettingsPanelWidth();
        mapSettingsPanel.classList.add("open");
        mapSettingsButton.setAttribute("aria-expanded", "true");
      }

      function closeSettingsPanel() {
        if (!mapSettingsPanel || !mapSettingsButton) {
          return;
        }
        mapSettingsPanel.classList.remove("open");
        mapSettingsButton.setAttribute("aria-expanded", "false");
      }

      function toggleSettingsPanel() {
        if (!mapSettingsPanel) {
          return;
        }
        if (mapSettingsPanel.classList.contains("open")) {
          closeSettingsPanel();
        } else {
          openSettingsPanel();
        }
      }

      function syncSettingsPanelWidth() {
        if (!mapSettingsPanel || !networkPanel) {
          return;
        }
        const panelWidth = networkPanel.getBoundingClientRect().width;
        if (panelWidth > 0) {
          mapSettingsPanel.style.width = `${panelWidth}px`;
        }
      }

      function resolveCssColor(name, fallback) {
        const value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return value || fallback;
      }

      function resolveStationName(row) {
        return row?.display_name
          || row?.station?.display_name
          || "Unknown station";
      }

      function resolveConnectorCode(row) {
        return row?.connector_code
          || row?.connector?.connector_code
          || row?.station?.connector_code
          || row?.station?.connector?.connector_code
          || null;
      }

      function resolveConnectorLabel(row) {
        const label = row?.connector_label
          || row?.connector?.label
          || row?.station?.connector_label
          || row?.station?.connector?.label
          || null;
        if (label) {
          return label;
        }
        const code = resolveConnectorCode(row);
        return code ? getConnectorLabelByCode(code) : "Unknown connector";
      }

      function resolveNetworkMemberships(row) {
        const memberships = row?.station?.station_network_memberships
          || row?.station_network_memberships
          || row?.station?.network_memberships
          || row?.network_memberships
          || [];
        if (!Array.isArray(memberships)) {
          return [];
        }
        return memberships.map((entry) => {
          const code = entry?.network_code
            || entry?.connector_code
            || entry?.code
            || null;
          if (!code) {
            return null;
          }
          return {
            code,
            label: entry?.network_label || entry?.label || null,
          };
        }).filter(Boolean);
      }

      function collectNetworkEntries(row) {
        const memberships = resolveNetworkMemberships(row);
        if (memberships.length) {
          return memberships;
        }
        const fallbackCode = resolveConnectorCode(row);
        if (!fallbackCode) {
          return [];
        }
        return [{
          code: fallbackCode,
          label: row?.connector_label || row?.connector?.label || null,
        }];
      }

      function buildNetworkDefs(rows) {
        const byCode = new Map();
        rows.forEach((row) => {
          collectNetworkEntries(row).forEach((entry) => {
            if (!entry.code || byCode.has(entry.code)) {
              return;
            }
            byCode.set(entry.code, {
              code: entry.code,
              label: entry.label || entry.code,
            });
          });
        });
        return Array.from(byCode.values()).sort((a, b) => a.label.localeCompare(b.label));
      }

      function getCurrentNetworkSelection() {
        if (!networkInputs.length) {
          return null;
        }
        return new Set(
          networkInputs
            .filter((input) => input.checked)
            .map((input) => input.dataset.network)
            .filter(Boolean)
        );
      }

      function renderNetworkFilters(defs, selectedCodes, defaultAll) {
        if (!networkList) {
          return;
        }
        networkList.innerHTML = "";
        networkInputs = [];
        if (!defs.length) {
          networkList.innerHTML = '<span class="network-empty">No networks available.</span>';
          syncNetworkActionState();
          return;
        }
        const fragment = document.createDocumentFragment();
        const hasSelection = selectedCodes !== null && selectedCodes !== undefined;
        defs.forEach((def) => {
          const label = document.createElement("label");
          label.className = "checkbox";
          const input = document.createElement("input");
          input.type = "checkbox";
          input.dataset.network = def.code;
          input.checked = defaultAll || (hasSelection ? selectedCodes.has(def.code) : true);
          const text = document.createElement("span");
          text.textContent = def.label;
          label.append(input, text);
          fragment.appendChild(label);
        });
        networkList.appendChild(fragment);
        networkInputs = Array.from(networkList.querySelectorAll("input[data-network]"));
        networkInputs.forEach((input) => input.addEventListener("change", handleNetworkToggle));
        syncNetworkActionState();
      }

      function syncNetworkActionState() {
        if (!networkSelectAll || !networkDeselectAll) {
          return;
        }
        const hasNetworks = networkInputs.length > 0;
        networkSelectAll.disabled = !hasNetworks;
        networkDeselectAll.disabled = !hasNetworks;
        if (!hasNetworks) {
          return;
        }
        const allChecked = networkInputs.every((input) => input.checked);
        const noneChecked = networkInputs.every((input) => !input.checked);
        networkSelectAll.disabled = allChecked;
        networkDeselectAll.disabled = noneChecked;
      }

      function resolveNetworkCodes(row) {
        return collectNetworkEntries(row).map((entry) => entry.code);
      }

      function resolvePconCode(row) {
        return row?.pcon_code
          || row?.pcon
          || row?.station?.pcon_code
          || row?.station?.pcon
          || row?.station?.pconCode
          || null;
      }

      function resolveStationKey(row) {
        return row?.station_id
          || row?.station?.id
          || row?.station_ref
          || row?.station?.station_ref
          || row?.station?.ref
          || row?.display_name
          || row?.station?.display_name
          || null;
      }

      function resolveLatestValue(row) {
        return clampPm25(
          row?.last_value
          ?? row?.latest_value
          ?? row?.value
          ?? row?.observed_value
          ?? row?.lastValue
          ?? row?.latestValue
        );
      }

      function resolveLatestTimestamp(row) {
        return parseDate(row?.last_value_at || row?.observed_at || row?.latest_value_at);
      }

      function extractPollutantText(row) {
        return [
          row?.pollutant_label,
          row?.phenomenon_label,
          row?.phenomenon?.pollutant_label,
          row?.phenomenon?.notation,
          row?.phenomenon?.label,
        ].filter(Boolean).join(" ").trim().toLowerCase();
      }

      function isPm25Text(value) {
        if (!value) {
          return false;
        }
        return /pm\s*2\s*\.?\s*5/.test(value)
          || value.includes("pm25")
          || value.includes("pm_2.5")
          || (value.includes("particulate") && /2\s*\.?\s*5/.test(value));
      }

      function isPm25Row(row) {
        return isPm25Text(extractPollutantText(row));
      }

      function updateSummary() {
        if (!pconRows.length) {
          summaryStations.textContent = "-";
        } else {
          const totalStations = pconRows.reduce((total, row) => {
            const count = normalizeNumber(row.station_count);
            return total + (count ?? 0);
          }, 0);
          summaryStations.textContent = formatNumber(totalStations);
        }

        const pollutantHint = typeof latestPollutant === "string"
          ? latestPollutant.toLowerCase()
          : "";
        const hasPm25Hint = isPm25Text(pollutantHint) || (!pollutantHint && latestRows.length > 0);
        const rowsForSummary = hasPm25Hint
          ? latestRows
          : latestRows.filter((row) => isPm25Row(row));
        const rowsWithPcon = rowsForSummary.filter((row) => resolvePconCode(row));
        let candidates = rowsWithPcon
          .map((row) => {
            const value = clampPm25(row.last_value);
            if (!Number.isFinite(value)) {
              return null;
            }
            return { row, value };
          })
          .filter(Boolean);

        if (!candidates.length && latestRows.length && !hasPm25Hint) {
          const fallback = latestRows
            .filter((row) => resolvePconCode(row))
            .map((row) => {
                const value = clampPm25(row.last_value);
              if (!Number.isFinite(value)) {
                return null;
              }
              return { row, value };
            })
            .filter(Boolean);
          if (fallback.length) {
            candidates = fallback;
          }
        }

        if (!candidates.length) {
          summaryLowestValue.textContent = "-";
          summaryLowestConnector.textContent = "-";
          summaryLowestName.textContent = "No PM2.5 data";
          summaryHighestValue.textContent = "-";
          summaryHighestConnector.textContent = "-";
          summaryHighestName.textContent = "No PM2.5 data";
          return;
        }

        const candidatesForLowest = candidates.filter(({ value }) => value > MIN_VALID_PM25_VALUE);
        const lowestPool = candidatesForLowest.length ? candidatesForLowest : candidates;

        let lowest = lowestPool[0];
        for (const candidate of lowestPool) {
          if (candidate.value < lowest.value) {
            lowest = candidate;
          }
        }

        let highest = candidates[0];
        for (const candidate of candidates) {
          if (candidate.value > highest.value) {
            highest = candidate;
          }
        }

        summaryLowestValue.textContent = `${formatValue(lowest.value)} µg/m³`;
        summaryLowestConnector.textContent = resolveConnectorLabel(lowest.row);
        summaryLowestName.textContent = resolveStationName(lowest.row);
        summaryHighestValue.textContent = `${formatValue(highest.value)} µg/m³`;
        summaryHighestConnector.textContent = resolveConnectorLabel(highest.row);
        summaryHighestName.textContent = resolveStationName(highest.row);
      }

      function updateRowCountText() {
        const withData = pconRows.filter((row) => getStationCount(row) > 0);
        rowCount.textContent = `${formatNumber(withData.length)} of ${formatNumber(pconCodes.size)} constituencies with PM2.5 data`;
      }

      function updateLegend(minValue, maxValue, capValue) {
        if (minValue === null || maxValue === null || capValue === null) {
          legendLabel.textContent = "No PM2.5 values";
          legendMin.textContent = "-";
          legendMax.textContent = "-";
          return;
        }
        legendLabel.textContent = METRIC_LABELS[currentMetric];
        legendMin.textContent = formatValue(minValue);
        legendMax.textContent = `${formatValue(capValue)}+`;
      }

      function mapValueToT(value, capValue) {
        if (!Number.isFinite(value) || !Number.isFinite(capValue) || capValue <= 0) {
          return 0;
        }
        const clamped = Math.max(0, Math.min(capValue, value));
        const ratio = clamped / capValue;
        if (currentColorScale === "linear") {
          return Math.max(0, Math.min(1, ratio));
        }
        const exponent = 0.8;
        const base = Math.pow(ratio, exponent);
        const boosted = base + 0.05 * base * base; // small top boost to keep 40 near ~87%
        return Math.max(0, Math.min(1, boosted));
      }

      function updateLegendTicks(capValue) {
        if (!legendTicks.length || !legendTickLabels.length) {
          return;
        }
        const updatePosition = (element) => {
          const value = Number(element.dataset.value);
          if (!Number.isFinite(value)) {
            return;
          }
          const t = mapValueToT(value, capValue);
          element.style.left = `${(t * 100).toFixed(1)}%`;
        };
        legendTicks.forEach(updatePosition);
        legendTickLabels.forEach(updatePosition);
      }

      function clearMap() {
        svg.selectAll("*").remove();
      }

      function offsetToPixel(layout, q, r, size) {
        if (layout === "odd-r") {
          return {
            x: size * Math.sqrt(3) * (q + 0.5 * (r & 1)),
            y: size * 1.5 * r,
          };
        }
        if (layout === "even-r") {
          return {
            x: size * Math.sqrt(3) * (q + 0.5 * ((r + 1) & 1)),
            y: size * 1.5 * r,
          };
        }
        if (layout === "odd-q") {
          return {
            x: size * 1.5 * q,
            y: size * Math.sqrt(3) * (r + 0.5 * (q & 1)),
          };
        }
        if (layout === "even-q") {
          return {
            x: size * 1.5 * q,
            y: size * Math.sqrt(3) * (r + 0.5 * ((q + 1) & 1)),
          };
        }
        return {
          x: size * Math.sqrt(3) * (q + r / 2),
          y: size * 1.5 * r,
        };
      }

      function computeHexBounds(cells, side) {
        const dx = (Math.sqrt(3) / 2) * side;
        const dy = side;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        cells.forEach((cell) => {
          const left = cell.cx - dx;
          const right = cell.cx + dx;
          const bottom = cell.cy - dy;
          const top = cell.cy + dy;
          if (left < minX) {
            minX = left;
          }
          if (bottom < minY) {
            minY = bottom;
          }
          if (right > maxX) {
            maxX = right;
          }
          if (top > maxY) {
            maxY = top;
          }
        });
        return { minX, minY, maxX, maxY };
      }

      function buildHexCellsFromHexjson(hexjson) {
        const layout = typeof hexjson?.layout === "string" ? hexjson.layout : "odd-r";
        const entries = Object.entries(hexjson?.hexes || {});
        const size = 1;
        const cells = entries.map(([key, value]) => {
          const q = Number(value?.q ?? value?.col ?? 0);
          const r = Number(value?.r ?? value?.row ?? 0);
          const { x, y } = offsetToPixel(layout, q, r, size);
          return {
            id: key,
            cx: x,
            cy: y,
            q,
            r,
            pcon_code: key,
            pcon_name: value?.n || null,
            region_code: value?.region || null,
            region_name: REGION_NAMES[value?.region] || null,
          };
        });
        return { cells, bounds: computeHexBounds(cells, size), side: size, layout };
      }

      function offsetToAxial(layout, col, row) {
        if (layout === "odd-r") {
          return { q: col - (row - (row & 1)) / 2, r: row };
        }
        if (layout === "even-r") {
          return { q: col - (row + (row & 1)) / 2, r: row };
        }
        if (layout === "odd-q") {
          return { q: col, r: row - (col - (col & 1)) / 2 };
        }
        if (layout === "even-q") {
          return { q: col, r: row - (col + (col & 1)) / 2 };
        }
        return { q: col, r: row };
      }

      function axialToOffset(layout, q, r) {
        if (layout === "odd-r") {
          return { col: q + (r - (r & 1)) / 2, row: r };
        }
        if (layout === "even-r") {
          return { col: q + (r + (r & 1)) / 2, row: r };
        }
        if (layout === "odd-q") {
          return { col: q, row: r + (q - (q & 1)) / 2 };
        }
        if (layout === "even-q") {
          return { col: q, row: r + (q + (q & 1)) / 2 };
        }
        return { col: q, row: r };
      }

      function getEdgeDirectionMap(layout) {
        if (EDGE_DIRECTION_CACHE.has(layout)) {
          return EDGE_DIRECTION_CACHE.get(layout);
        }
        const size = 1;
        const center = offsetToPixel(layout, 0, 0, size);
        const points = hexPoints(center.x, center.y, size);
        const edgeVectors = points.map((point, index) => {
          const next = points[(index + 1) % 6];
          return {
            x: (point[0] + next[0]) / 2 - center.x,
            y: (point[1] + next[1]) / 2 - center.y,
          };
        });
        const directionVectors = AXIAL_DIRECTIONS.map((dir) => {
          const offset = axialToOffset(layout, dir.q, dir.r);
          const neighbor = offsetToPixel(layout, offset.col, offset.row, size);
          return {
            x: neighbor.x - center.x,
            y: neighbor.y - center.y,
          };
        });
        const map = edgeVectors.map((edgeVector) => {
          let bestIndex = 0;
          let bestScore = -Infinity;
          const edgeLength = Math.hypot(edgeVector.x, edgeVector.y) || 1;
          directionVectors.forEach((directionVector, directionIndex) => {
            const dirLength = Math.hypot(directionVector.x, directionVector.y) || 1;
            const score = (edgeVector.x * directionVector.x + edgeVector.y * directionVector.y)
              / (edgeLength * dirLength);
            if (score > bestScore) {
              bestScore = score;
              bestIndex = directionIndex;
            }
          });
          return bestIndex;
        });
        EDGE_DIRECTION_CACHE.set(layout, map);
        return map;
      }

      function neighborForEdge(layout, col, row, edgeIndex) {
        const axial = offsetToAxial(layout, col, row);
        const directionIndex = getEdgeDirectionMap(layout)[edgeIndex];
        const direction = AXIAL_DIRECTIONS[directionIndex];
        const neighborAxial = { q: axial.q + direction.q, r: axial.r + direction.r };
        return axialToOffset(layout, neighborAxial.q, neighborAxial.r);
      }

      function buildPathsFromSegments(segments) {
        const pointKey = (point) => `${point[0].toFixed(6)},${point[1].toFixed(6)}`;
        const adjacency = new Map();
        segments.forEach((segment, index) => {
          const startKey = pointKey(segment.start);
          const endKey = pointKey(segment.end);
          if (!adjacency.has(startKey)) {
            adjacency.set(startKey, []);
          }
          if (!adjacency.has(endKey)) {
            adjacency.set(endKey, []);
          }
          adjacency.get(startKey).push(index);
          adjacency.get(endKey).push(index);
        });
        const unused = new Set(segments.map((_, index) => index));
        const paths = [];
        const takeSegment = (key) => {
          const candidates = adjacency.get(key);
          if (!candidates) {
            return null;
          }
          const nextIndex = candidates.find((index) => unused.has(index));
          if (nextIndex === undefined) {
            return null;
          }
          unused.delete(nextIndex);
          return nextIndex;
        };
        while (unused.size) {
          const index = unused.values().next().value;
          unused.delete(index);
          const segment = segments[index];
          const path = [segment.start, segment.end];
          let startKey = pointKey(segment.start);
          let endKey = pointKey(segment.end);
          while (true) {
            const nextIndex = takeSegment(endKey);
            if (nextIndex === null) {
              break;
            }
            const nextSegment = segments[nextIndex];
            const nextPoint = pointKey(nextSegment.start) === endKey
              ? nextSegment.end
              : nextSegment.start;
            path.push(nextPoint);
            endKey = pointKey(nextPoint);
          }
          while (true) {
            const prevIndex = takeSegment(startKey);
            if (prevIndex === null) {
              break;
            }
            const prevSegment = segments[prevIndex];
            const prevPoint = pointKey(prevSegment.start) === startKey
              ? prevSegment.end
              : prevSegment.start;
            path.unshift(prevPoint);
            startKey = pointKey(prevPoint);
          }
          paths.push(path);
        }
        return paths;
      }

      function regionCountry(regionCode) {
        if (!regionCode) {
          return null;
        }
        return String(regionCode).trim().charAt(0) || null;
      }

      function boundaryType(regionCode, neighborCode) {
        const country = regionCountry(regionCode);
        const neighborCountry = regionCountry(neighborCode) || country;
        if (!neighborCode) {
          return null;
        }
        if (country && neighborCountry && country !== neighborCountry) {
          return "country";
        }
        return "region";
      }

      function buildRegionBoundaryPaths(cells, layout) {
        const cellLookup = new Map(cells.map((cell) => [`${cell.q},${cell.r}`, cell]));
        const segmentsByType = { region: [], country: [] };
        cells.forEach((cell) => {
          const points = hexPoints(cell.cx, cell.cy, 1);
          for (let edgeIndex = 0; edgeIndex < 6; edgeIndex += 1) {
            const neighborOffset = neighborForEdge(layout, cell.q, cell.r, edgeIndex);
            const neighborKey = `${neighborOffset.col},${neighborOffset.row}`;
            const neighbor = cellLookup.get(neighborKey);
            if (!neighbor) {
              continue;
            }
            const neighborRegion = neighbor?.region_code || null;
            if (neighborRegion === cell.region_code) {
              continue;
            }
            if (neighborRegion && cell.region_code && cell.region_code > neighborRegion) {
              continue;
            }
            const type = boundaryType(cell.region_code, neighborRegion);
            if (!type) {
              continue;
            }
            segmentsByType[type].push({
              start: points[edgeIndex],
              end: points[(edgeIndex + 1) % 6],
            });
          }
        });
        return Object.entries(segmentsByType)
          .map(([type, segments]) => ({
            type,
            paths: buildPathsFromSegments(segments),
          }))
          .filter((boundary) => boundary.paths.length);
      }

      function prepareHexGrid() {
        if (!hexData || hexCells.length) {
          return;
        }
        const { cells, bounds, side, layout } = buildHexCellsFromHexjson(hexData);
        hexCells = cells;
        hexBounds = bounds;
        hexSide = side;
        hexLayout = layout;
        boundaryPaths = buildRegionBoundaryPaths(cells, layout);
      }

      function createProjection(bounds, width, height, padding) {
        const dataWidth = bounds.maxX - bounds.minX;
        const dataHeight = bounds.maxY - bounds.minY;
        const scale = Math.min(
          (width - padding * 2) / dataWidth,
          (height - padding * 2) / dataHeight,
        );
        const extraX = width - padding * 2 - dataWidth * scale;
        const extraY = height - padding * 2 - dataHeight * scale;
        return (point) => ([
          (point[0] - bounds.minX) * scale + padding + extraX / 2,
          (bounds.maxY - point[1]) * scale + padding + extraY / 2,
        ]);
      }

      function hexPoints(cx, cy, side) {
        const dx = Math.sqrt(3) / 2 * side;
        const dy = side / 2;
        return [
          [cx, cy + side],
          [cx + dx, cy + dy],
          [cx + dx, cy - dy],
          [cx, cy - side],
          [cx - dx, cy - dy],
          [cx - dx, cy + dy],
        ];
      }

      function applyMetricState() {
        metricButtons.forEach((button) => {
          const isActive = button.dataset.metric === currentMetric;
          button.classList.toggle("active", isActive);
        });
      }

      function getMetricValue(row) {
        if (!row) {
          return null;
        }
        const raw = currentMetric === "mean"
          ? row.mean_value
          : row.median_value;
        return clampPm25(raw);
      }

      function getStationCount(row) {
        if (!row) {
          return 0;
        }
        const count = normalizeNumber(row.station_count);
        return count === null ? 0 : count;
      }

      function getActiveNetworkIds() {
        if (!networkInputs.length) {
          return null;
        }
        const active = networkInputs
          .filter((input) => input.checked)
          .map((input) => input.dataset.network)
          .filter(Boolean);
        if (!active.length) {
          return new Set();
        }
        if (active.length === networkInputs.length) {
          return null;
        }
        return new Set(active);
      }

      function filterLatestRowsByNetwork(rows, networkIds) {
        if (!rows.length) {
          return [];
        }
        return rows.filter((row) => {
          const codes = resolveNetworkCodes(row);
          return codes.some((code) => networkIds.has(code));
        });
      }

      function buildPconRowsFromLatest(rows) {
        if (!rows.length) {
          return [];
        }
        const groups = new Map();
        rows.forEach((row, index) => {
          const pollutantText = extractPollutantText(row);
          if (pollutantText && !isPm25Text(pollutantText)) {
            return;
          }
          const pconCode = resolvePconCode(row);
          if (!pconCode) {
            return;
          }
          const value = resolveLatestValue(row);
          if (!Number.isFinite(value)) {
            return;
          }
          const stationKey = resolveStationKey(row) || `${pconCode}-${index}`;
          const timestamp = parseDate(row?.last_value_at || row?.observed_at || row?.latest_value_at);
          const group = groups.get(pconCode) || { stations: new Map(), latestAt: null };
          const existing = group.stations.get(stationKey);
          if (!existing || (timestamp && (!existing.timestamp || timestamp > existing.timestamp))) {
            group.stations.set(stationKey, { value, timestamp });
          }
          if (timestamp && (!group.latestAt || timestamp > group.latestAt)) {
            group.latestAt = timestamp;
          }
          groups.set(pconCode, group);
        });

        const rowsForMap = [];
        groups.forEach((group, pconCode) => {
          const values = Array.from(group.stations.values())
            .map((entry) => entry.value)
            .filter((value) => Number.isFinite(value));
          if (!values.length) {
            return;
          }
          const sorted = [...values].sort((a, b) => a - b);
          const midpoint = Math.floor(sorted.length / 2);
          const median = sorted.length % 2 === 0
            ? (sorted[midpoint - 1] + sorted[midpoint]) / 2
            : sorted[midpoint];
          const mean = values.reduce((sum, value) => sum + value, 0) / values.length;
          const baseRow = basePconLookup.get(pconCode) || {};
          rowsForMap.push({
            pcon_code: pconCode,
            pcon_name: baseRow.pcon_name || null,
            pcon_version: baseRow.pcon_version || activePconVersion,
            station_count: values.length,
            single_site: values.length === 1,
            median_value: median,
            mean_value: mean,
            latest_value_at: group.latestAt ? group.latestAt.toISOString() : null,
          });
        });
        return rowsForMap;
      }

      function applyNetworkFilters() {
        if (!basePconRows.length && !baseLatestRows.length) {
          return;
        }
        const networkIds = getActiveNetworkIds();
        if (networkIds === null) {
          pconRows = basePconRows;
          latestRows = baseLatestRows;
        } else if (networkIds.size === 0) {
          pconRows = [];
          latestRows = [];
        } else {
          const filteredLatest = filterLatestRowsByNetwork(baseLatestRows, networkIds);
          latestRows = filteredLatest;
          const derived = buildPconRowsFromLatest(filteredLatest);
          if (derived.length) {
            pconRows = derived;
          } else {
            pconRows = [];
          }
        }
        pconLookup = new Map(pconRows.map((row) => [row.pcon_code, row]));
        updateRowCountText();
        updateSummary();
        renderMap();
      }

      function positionTooltip(event) {
        const left = event.clientX + 12;
        const pointerY = event.clientY;
        const viewportTop = 0;
        const viewportBottom = window.innerHeight;
        const tooltipHeight = tooltip.offsetHeight || 0;
        let top = pointerY - 12;
        if (top + tooltipHeight > viewportBottom) {
          top = pointerY - tooltipHeight - 12;
        }
        if (top < viewportTop + 8) {
          top = viewportTop + 8;
        }
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      }

      function handleNetworkAction(event) {
        if (!networkInputs.length) {
          return;
        }
        if (event.target === networkSelectAll) {
          networkInputs.forEach((input) => {
            input.checked = true;
          });
        } else if (event.target === networkDeselectAll) {
          networkInputs.forEach((input) => {
            input.checked = false;
          });
        }
        syncNetworkActionState();
        applyNetworkFilters();
      }

      function handleNetworkToggle() {
        syncNetworkActionState();
        applyNetworkFilters();
      }

      function renderMap() {
        if (!hexData || !hexCells.length || !hexBounds || !hexSide) {
          return;
        }
        clearMap();
        const width = svg.node().clientWidth || 960;
        const height = svg.node().clientHeight || 560;
        const projection = createProjection(hexBounds, width, height, 24);
        const values = pconRows
          .map((row) => getMetricValue(row))
          .filter((value) => Number.isFinite(value));
        const maxValue = values.length ? d3.max(values) : null;
        const domainMin = 0;
        const domainMax = 50;
        const palette = HEAT_STOPS.map((name, index) =>
          resolveCssColor(name, HEAT_STOP_FALLBACKS[index])
        );
        let colorScale = null;
        if (maxValue !== null) {
          const interpolate = d3.interpolateRgbBasis(palette);
          colorScale = (value) => interpolate(mapValueToT(value, domainMax));
        }
        updateLegend(maxValue === null ? null : domainMin, maxValue, domainMax);
        updateLegendScaleDescription();
        updateLegendTicks(domainMax);

        const hexGroup = svg.append("g");
        hexGroup.selectAll("polygon")
          .data(hexCells)
          .join("polygon")
          .attr("class", "hex")
          .attr("points", (cell) => hexPoints(cell.cx, cell.cy, hexSide)
            .map((point) => projection(point))
            .map((point) => `${point[0]},${point[1]}`)
            .join(" "))
          .attr("fill", (cell) => {
            const row = pconLookup.get(cell.pcon_code);
            const value = getMetricValue(row);
            if (!colorScale || !Number.isFinite(value)) {
              return "var(--no-data)";
            }
            return colorScale(value);
          })
          .on("mouseenter", (event, cell) => {
            const row = pconLookup.get(cell.pcon_code);
            const metricValue = getMetricValue(row);
            const areaName = cell.pcon_name || row?.pcon_name || cell.pcon_code || "Unknown constituency";
            const regionLabel = cell.region_name || cell.region_code || "Unknown region";
            const populationEntry = populationLookup.get(cell.pcon_code);
            const populationValue = normalizeNumber(populationEntry?.population_value);
            const populationDate = parseDate(populationEntry?.reference_date);
            const populationYear = populationDate ? populationDate.getFullYear() : null;
            const populationLabel = populationValue === null
              ? "Population: n/a"
              : `Population${populationYear ? ` (${populationYear})` : ""}: ${formatNumber(populationValue)}`;
            const valueLabel = Number.isFinite(metricValue)
              ? `${formatValue(metricValue)} µg/m³`
              : "No PM2.5 data";
            const pollutantHint = typeof latestPollutant === "string"
              ? latestPollutant.toLowerCase()
              : "";
            const useAllPm25 = isPm25Text(pollutantHint) || (!pollutantHint && latestRows.length > 0);
            const rowsForTooltip = (useAllPm25 ? latestRows : latestRows.filter((item) => isPm25Row(item)))
              .filter((item) => resolvePconCode(item) === cell.pcon_code);
            const stationMap = new Map();
            rowsForTooltip.forEach((item, index) => {
              const value = resolveLatestValue(item);
              if (!Number.isFinite(value)) {
                return;
              }
              const stationKey = resolveStationKey(item) || `${cell.pcon_code}-${index}`;
              const timestamp = resolveLatestTimestamp(item);
              const existing = stationMap.get(stationKey);
              if (!existing || (timestamp && (!existing.timestamp || timestamp > existing.timestamp))) {
                stationMap.set(stationKey, { row: item, value, timestamp });
              }
            });
            const stationEntries = Array.from(stationMap.values());
            if (!stationEntries.length) {
              tooltip.innerHTML = `
                <div class="tooltip-title">${areaName}</div>
                <div class="tooltip-line">Region: ${regionLabel}</div>
                <div class="tooltip-line">${populationLabel}</div>
                <div class="tooltip-empty">No stations</div>
              `;
            } else {
              const stationHeading = stationEntries.length === 1
                ? "1 station"
                : `${formatNumber(stationEntries.length)} stations`;
              const grouped = new Map();
              stationEntries.forEach((entry) => {
                const connectorLabel = resolveConnectorLabel(entry.row);
                if (!grouped.has(connectorLabel)) {
                  grouped.set(connectorLabel, []);
                }
                grouped.get(connectorLabel).push(entry);
              });
              let tableRows = `
                <div class="tooltip-head">${stationHeading}</div>
                <div class="tooltip-head">PM2.5</div>
                <div class="tooltip-head">Updated</div>
                <div class="tooltip-row-divider tooltip-row-divider--header" aria-hidden="true"></div>
              `;
              let groupIndex = 0;
              grouped.forEach((entries, connectorLabel) => {
                if (groupIndex > 0) {
                  tableRows += '<div class="tooltip-row-divider" aria-hidden="true"></div>';
                }
                const connectorClass = groupIndex === 0
                  ? "tooltip-connector"
                  : "tooltip-connector tooltip-connector--spaced";
                tableRows += `
                  <div class="${connectorClass}">${connectorLabel}</div>
                `;
                entries.forEach((entry) => {
                  const stationName = resolveStationName(entry.row);
                  const updatedText = formatShortTimestamp(entry.timestamp);
                  tableRows += `
                    <div class="tooltip-station">${stationName}</div>
                    <div class="tooltip-value">${formatValue(entry.value)}</div>
                    <div class="tooltip-updated">${updatedText}</div>
                  `;
                });
                groupIndex += 1;
              });
              tooltip.innerHTML = `
                <div class="tooltip-title">${areaName}</div>
                <div class="tooltip-line">Region: ${regionLabel}</div>
                <div class="tooltip-line">${populationLabel}</div>
                <div class="tooltip-line">${METRIC_LABELS[currentMetric]}: ${valueLabel}</div>
                <div class="tooltip-table">${tableRows}
                  <div class="tooltip-vline tooltip-vline--1" aria-hidden="true"></div>
                  <div class="tooltip-vline tooltip-vline--2" aria-hidden="true"></div>
                </div>
              `;
            }
            tooltip.classList.add("visible");
            positionTooltip(event);
          })
          .on("mousemove", (event) => {
            positionTooltip(event);
          })
          .on("mouseleave", () => {
            tooltip.classList.remove("visible");
          });

        const boundaryGroup = svg.append("g").attr("class", "region-boundaries");
        boundaryGroup.selectAll("path")
          .data(boundaryPaths)
          .join("path")
          .attr("class", (boundary) => `boundary-path boundary-${boundary.type || "region"}`)
          .attr("d", (boundary) => boundary.paths.map((path) => {
            const [first, ...rest] = path;
            const [startX, startY] = projection(first);
            const lines = rest.map((point) => {
              const [x, y] = projection(point);
              return `L${x},${y}`;
            }).join("");
            return `M${startX},${startY}${lines}`;
          }).join(""));
      }

      async function loadMapData() {
        statusEl.textContent = "Loading…";
        errorEl.textContent = "";
        latestPollutant = null;
        populationLookup = new Map();
        const previousSelection = getCurrentNetworkSelection();
        const hadAllSelected = networkInputs.length > 0
          && networkInputs.every((input) => input.checked);
        if (!REST_URL) {
          errorEl.textContent = "Missing project ref. Provide ?project_ref=... or inject at deploy.";
          statusEl.textContent = "Error";
          return;
        }
        if (!anonKey) {
          errorEl.textContent = "Missing anon key. Provide ?anon_key=... or inject at deploy.";
          statusEl.textContent = "Error";
          return;
        }
        try {
          const pconUrl = new URL(REST_URL);
          if (activePconVersion) {
            pconUrl.searchParams.set("pcon_version", activePconVersion);
          }
          const latestUrl = new URL(LATEST_URL);
          latestUrl.searchParams.set("pollutant", "PM2.5");
          latestUrl.searchParams.set("scope", "all");
          latestUrl.searchParams.set("limit", "10000");
          const populationUrl = POPULATION_URL ? new URL(POPULATION_URL) : null;
          if (populationUrl) {
            populationUrl.searchParams.set("geo_type", "PCON");
            if (mapDateKey) {
              populationUrl.searchParams.set("reference_date", mapDateKey);
            }
            populationUrl.searchParams.set("limit", "2000");
          }
          const [hexResponse, pconResponse, latestResponse, populationResponse] = await Promise.all([
            fetch(HEX_DATA_URL),
            fetch(pconUrl.toString(), {
              headers: {
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
            }),
            fetch(latestUrl.toString(), {
              headers: {
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
            }).catch(() => null),
            populationUrl
              ? fetch(populationUrl.toString(), {
                headers: {
                  Authorization: `Bearer ${anonKey}`,
                  apikey: anonKey,
                },
              }).catch(() => null)
              : Promise.resolve(null),
          ]);
          if (!hexResponse.ok) {
            throw new Error(`Hex data request failed: ${hexResponse.status}`);
          }
          if (!pconResponse.ok) {
            throw new Error(`Constituency request failed: ${pconResponse.status}`);
          }
          hexData = await hexResponse.json();
          prepareHexGrid();
          const payload = await pconResponse.json();
          basePconRows = payload?.data || [];
          basePconLookup = new Map(basePconRows.map((row) => [row.pcon_code, row]));
          pconRows = basePconRows;
          pconLookup = new Map(pconRows.map((row) => [row.pcon_code, row]));
          pconCodes = new Set(hexCells.map((cell) => cell.pcon_code).filter(Boolean));
          if (payload?.last_updated) {
            lastUpdated.textContent = `Latest data ${formatTimestamp(payload.last_updated)}`;
          } else {
            lastUpdated.textContent = "Latest data unavailable";
          }
          if (latestResponse && latestResponse.ok) {
            const latestPayload = await latestResponse.json();
            const latestRaw = latestPayload?.data || [];
            baseLatestRows = latestRaw.filter((row) => Number.isFinite(resolveLatestValue(row)));
            latestPollutant = latestPayload?.pollutant || null;
            console.log("uk_aq_latest payload", latestPayload);
          } else {
            baseLatestRows = [];
          }
          renderNetworkFilters(
            buildNetworkDefs(baseLatestRows),
            previousSelection,
            hadAllSelected
          );
          if (populationResponse && populationResponse.ok) {
            const populationPayload = await populationResponse.json();
            const populationRows = Array.isArray(populationPayload)
              ? populationPayload
              : populationPayload?.data || [];
            const lookup = new Map();
            populationRows.forEach((row) => {
              const code = row?.geo_code;
              if (!code || lookup.has(code)) {
                return;
              }
              lookup.set(code, row);
            });
            populationLookup = lookup;
          } else {
            populationLookup = new Map();
          }
          applyNetworkFilters();
          statusEl.textContent = "Live";
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          errorEl.textContent = message;
          statusEl.textContent = "Error";
        }
      }

      metricButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const metric = button.dataset.metric;
          if (!metric || metric === currentMetric) {
            return;
          }
          currentMetric = metric;
          applyMetricState();
          renderMap();
        });
      });

      colorScaleInputs.forEach((input) => {
        input.addEventListener("change", () => {
          if (input.checked && input.value !== currentColorScale) {
            currentColorScale = input.value;
            setQueryParam("color_scale", currentColorScale);
            updateLegendScaleDescription();
            renderMap();
          }
        });
      });

      if (mapSettingsButton) {
        mapSettingsButton.addEventListener("click", (event) => {
          event.stopPropagation();
          toggleSettingsPanel();
        });
      }

      if (mapSettingsClose) {
        mapSettingsClose.addEventListener("click", (event) => {
          event.stopPropagation();
          closeSettingsPanel();
        });
      }

      document.addEventListener("click", (event) => {
        if (!mapSettingsPanel || !mapSettingsPanel.classList.contains("open")) {
          return;
        }
        const target = event.target;
        if (mapSettingsPanel.contains(target) || (mapSettingsButton && mapSettingsButton.contains(target))) {
          return;
        }
        closeSettingsPanel();
      });

      if (networkSelectAll) {
        networkSelectAll.addEventListener("click", handleNetworkAction);
      }
      if (networkDeselectAll) {
        networkDeselectAll.addEventListener("click", handleNetworkAction);
      }

      document.getElementById("refresh").addEventListener("click", loadMapData);
      window.addEventListener("resize", () => {
        if (statusEl.textContent === "Live") {
          renderMap();
        }
        syncSettingsPanelWidth();
      });
      applyMetricState();
      syncSettingsPanelWidth();
      syncColorScaleInputs();
      updateLegendScaleDescription();
      loadMapData();
      setInterval(loadMapData, 10 * 60 * 1000);
    </script>
  </body>
</html>
